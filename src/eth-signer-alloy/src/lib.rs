use std::error::Error;

use alloy::signers::local::PrivateKeySigner;
use async_trait::async_trait;
// use ethers_core::types::transaction::eip2718::TypedTransaction;
// use ethers_core::types::{Address, Signature};
// pub use wallet::{Wallet, WalletError};

// mod wallet;

#[cfg(feature = "ic_sign")]
pub mod ic_sign;
pub mod sign_strategy;
pub mod transaction;

// /// A wallet instantiated with a locally stored private key
// // pub type LocalWallet<'a> = Wallet<'a, ethers_core::k256::ecdsa::SigningKey>;
pub type LocalWallet = PrivateKeySigner;
#[deprecated]
pub type WalletError = alloy::signers::Error;
pub type SignerError = alloy::signers::Error;

// /// Applies [EIP155](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md)
// pub fn to_eip155_v<T: Into<u8>>(recovery_id: T, chain_id: u64) -> u64 {
//     (recovery_id.into() as u64) + 35 + chain_id * 2
// }

// / Trait for signing transactions and messages
// /
// / Implement this trait to support different signing modes, e.g. Ledger, hosted etc.
// #[cfg_attr(target_arch = "wasm32", async_trait(?Send))]
// #[cfg_attr(not(target_arch = "wasm32"), async_trait)]
// pub trait Signer: std::fmt::Debug + Send + Sync {
//     type Error: Error + Send + Sync;

//     /// Signs the hash of the provided message after prefixing it
//     async fn sign_message<S: Send + Sync + AsRef<[u8]>>(
//         &self,
//         message: S,
//     ) -> Result<Signature, Self::Error>;

//     /// Signs the transaction
//     async fn sign_transaction(&self, message: &TypedTransaction) -> Result<Signature, Self::Error>;

//     /// Returns the signer's Ethereum Address
//     fn address(&self) -> Address;

//     /// Returns the signer's chain id
//     fn chain_id(&self) -> u64;

//     /// Sets the signer's chain id
//     #[must_use]
//     fn with_chain_id<T: Into<u64>>(self, chain_id: T) -> Self;
// }
